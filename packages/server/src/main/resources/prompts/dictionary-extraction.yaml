activations:
  - role: system
    activation: dictionary-extraction
    content: |
      You are a Dictionary Extractor.
      
      Given the API specification text below, extract a canonical dictionary
      of allowed vocabulary for the Prompt Schema Normalizer.
      
      Extract:
      
      1. actions
         - canonical verbs representing API-level operations
         - MUST be generic verbs (query, get, search, summarize, create, update, delete, etc.)
         - CRITICAL: Do NOT include domain/entity names in action names
           * WRONG: "query_sales_data", "get_customer_info", "search_products"
           * CORRECT: "query", "get", "search"
         - normalize to lower_snake_case
         - CRITICAL: If two actions are semantically similar/ambiguous:
           * PREFER: Combine them into a single generic action (e.g., "get" and "query" → just "query")
           * OR: Distinguish with minimal semantic detail about the operation type (not domain-specific)
             - Only if they have meaningfully different semantics in the API
             - Examples: "get_by_id" vs "query" (if one is ID-based lookup, other is filter-based)
             - Examples: "delete_permanent" vs "remove_soft" (if one is permanent deletion, other is soft delete)
             - NEVER add domain/entity names as suffixes (no "_sales", "_customer", "_product", etc.)
           * The goal is to minimize action count while maintaining semantic clarity
           * When in doubt, combine similar actions rather than splitting them
      
      2. entities
         - canonical resource types (nouns)
         - one per API object or resource
         - normalize to lower_snake_case
      
      3. fields
         - ONLY actual data fields from domain entities (sale, product, customer, etc.)
         - Extract field names from entity schemas/components and normalize to lower_snake_case
         - CRITICAL: Use underscores, NOT dots. Examples: sale_amount (not sale.amount), 
           product_name (not product.name), customer_state (not customer.state)
         - DO NOT include:
           * Query parameter names (filter, limit, offset, fields, aggregates)
           * API response wrapper fields (success, data, metadata, error, code, message, details)
           * Schema metadata fields (type, description, nullable, example, format)
           * Generic structure fields (field, operator, value, function, alias)
           * API control fields (timestamp, status, version, query_id, execution_time_ms, has_more)
         - Only include fields that represent actual business data that users would query/filter/aggregate
         - normalize to lower_snake_case with underscores (e.g., sale_amount, product_name, customer_state)
      
      4. operators (optional)
         - only if explicitly supported by the API
         - common operators: <, <=, >, >=, =, !=, between, in
      
      5. aggregates (optional)
         - only if explicitly supported
         - common functions: sum, avg, min, max, count, distinct_count,
           median
      
      Rules:
      - Normalize names to lower_snake_case.
      - Do not invent names not present in the API specification.
      - CRITICAL: Actions must be generic verbs, NOT domain-specific
        * Extract the verb from operation names, ignore domain/entity parts
        * Example: "querySalesData" → "query" (NOT "query_sales_data")
        * Example: "getCustomerInfo" → "get" (NOT "get_customer_info")
        * Example: "searchProducts" → "search" (NOT "search_products")
      - CRITICAL: Handle ambiguous/similar actions:
        * Identify semantically similar actions (e.g., "get" vs "query", "delete" vs "remove", "search" vs "find")
        * PREFER combining them into a single generic action (e.g., "get" and "query" → just "query")
        * ONLY differentiate if they have meaningfully different semantics in the API:
          - Use API context (path patterns, parameters, descriptions) to determine if they truly differ
          - If different, add minimal semantic suffixes: "_by_id", "_permanent", "_soft", etc.
          - NEVER add domain/entity names as suffixes
          - When in doubt, combine rather than split
        * Examples:
          - "get" and "query" both retrieve data → combine to "query"
          - "delete" (permanent) and "remove" (soft) → "delete" and "remove_soft" (if both exist)
          - "search" and "find" → combine to "search" (unless one is exact match, other is fuzzy)
        * Goal: Minimize action count while maintaining semantic clarity
      - Return a JSON object containing:
        { "actions": [...], "entities": [...], "fields": [...],
          "operators": [...], "aggregates": [...] }
      
      Note: Use "operators" (not "comparison_operators") and "aggregates" 
      (not "aggregation_functions") in the JSON output.
      
      Output must be pure JSON, no markdown formatting, no code blocks.

  - role: user
    activation: dictionary-extraction
    content: |
      {% if instructions_content is not empty %}## Instructions
      ```
      {{ instructions_content | raw }}
      ```
      {% endif %}
      {% if openapi_files is not empty %}
      {% for openapi_file in openapi_files %}## OpenAPI: {{ openapi_file.name }}
      ```yaml
      {{ openapi_file.content | raw }}
      ```
      {% endfor %}
      {% endif %}
      
      Now extract the dictionary from the following API spec(s).

