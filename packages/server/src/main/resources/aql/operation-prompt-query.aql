LET operation = FIRST(
  FOR op IN operations
    FILTER op._key == @operationKey OR op.operationId == @operationId
    RETURN op
)

LET operationDocs = (
  operation == null ? [] : (
    FOR doc IN 1..1 OUTBOUND operation edges
      FILTER doc.nodeType == 'documentation'
      RETURN doc
  )
)

LET operationExamples = (
  operation == null ? [] : (
    FOR ex IN 1..1 OUTBOUND operation edges
      FILTER ex.nodeType == 'example'
      RETURN ex
  )
)

// Get entities connected to this operation (via INBOUND edges from entities to operation)
LET directlyConnectedEntities = (
  operation == null ? [] : (
    FOR entity IN 1..1 INBOUND operation edges
      FILTER entity.nodeType == 'entity'
      RETURN entity
  )
)

// Get all entities related to directly connected entities (through relationships)
// This includes entities that are connected via entity-to-entity relationships
LET relatedEntitiesOutbound = (
  FOR entity IN directlyConnectedEntities
    FOR relatedEntity IN 1..1 OUTBOUND entity edges
      FILTER relatedEntity.nodeType == 'entity'
      RETURN relatedEntity
)

LET relatedEntitiesInbound = (
  FOR entity IN directlyConnectedEntities
    FOR relatedEntity IN 1..1 INBOUND entity edges
      FILTER relatedEntity.nodeType == 'entity'
      RETURN relatedEntity
)

// Combine all entities (directly connected + related) and remove duplicates by _key
LET allEntitiesRaw = UNION(directlyConnectedEntities, relatedEntitiesOutbound, relatedEntitiesInbound)
LET uniqueEntityKeys = (
  FOR entity IN allEntitiesRaw
    COLLECT key = entity._key INTO grouped
    RETURN key
)

// Re-fetch entities by their keys to ensure we have complete entity objects
LET allEntities = (
  FOR key IN uniqueEntityKeys
    LET entity = FIRST(
      FOR e IN entities
        FILTER e._key == key
        RETURN e
    )
    FILTER entity != null
    RETURN entity
)

// Get relationships between entities (entity-to-entity relationships)
// Get both OUTBOUND and INBOUND relationships to capture bidirectional connections
LET allEntityKeys = (
  FOR entity IN allEntities
    RETURN entity._key
)

LET outboundRelationships = (
  FOR entity IN allEntities
    FOR relatedEntity, edge IN 1..1 OUTBOUND entity edges
      FILTER relatedEntity.nodeType == 'entity' AND relatedEntity._key IN allEntityKeys
      RETURN {
        fromEntity: entity.name,
        toEntity: relatedEntity.name,
        relationshipType: edge.edgeType,
        description: edge.description,
        strength: edge.strength
      }
)

LET inboundRelationships = (
  FOR entity IN allEntities
    FOR relatedEntity, edge IN 1..1 INBOUND entity edges
      FILTER relatedEntity.nodeType == 'entity' AND relatedEntity._key IN allEntityKeys
      RETURN {
        fromEntity: relatedEntity.name,
        toEntity: entity.name,
        relationshipType: edge.edgeType,
        description: edge.description,
        strength: edge.strength
      }
)

LET operationRelationships = UNION(outboundRelationships, inboundRelationships)

// Get fields for each entity (including related entities)
// Re-fetch entities by key before traversing to ensure graph traversal works correctly
LET entityFields = (
  FOR entityKey IN uniqueEntityKeys
    LET entity = FIRST(
      FOR e IN entities
        FILTER e._key == entityKey
        RETURN e
    )
    FILTER entity != null
    LET fields = (
      FOR field IN 1..1 OUTBOUND entity edges
        FILTER field.nodeType == 'field'
        RETURN {
          name: field.name,
          type: field.fieldType,
          description: field.description,
          example: field.example,
          possibleValues: field.possibleValues != null ? field.possibleValues : []
        }
    )
    RETURN {
      entityName: entity.name,
      entityDescription: entity.description,
      fields: fields
    }
)

// Get input schema from operation (requestSchema)
LET inputSchema = operation != null ? operation.requestSchema : null

// Get output schema from operation (responseSchema)
LET outputSchema = operation != null ? operation.responseSchema : null

// Get operators and aggregation functions from documentation
LET operatorsDoc = FIRST(
  FOR doc IN operationDocs
    FILTER doc.docType == 'operators_reference' OR CONTAINS(LOWER(doc.content), 'operator')
    RETURN doc
)

LET aggregationDoc = FIRST(
  FOR doc IN operationDocs
    FILTER doc.docType == 'aggregation_reference' OR CONTAINS(LOWER(doc.content), 'aggregation')
    RETURN doc
)

RETURN {
  operation: operation,
  documentation: operationDocs,
  relationships: operationRelationships,
  examples: operationExamples,
  entityFields: entityFields,
  inputSchema: inputSchema,
  outputSchema: outputSchema,
  operatorsDoc: operatorsDoc,
  aggregationDoc: aggregationDoc
}

