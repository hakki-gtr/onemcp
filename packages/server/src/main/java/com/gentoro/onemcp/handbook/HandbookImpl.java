package com.gentoro.onemcp.handbook;

import com.gentoro.onemcp.OneMcp;
import com.gentoro.onemcp.exception.ConfigException;
import com.gentoro.onemcp.exception.ExceptionUtil;
import com.gentoro.onemcp.exception.IoException;
import com.gentoro.onemcp.exception.NotFoundException;
import com.gentoro.onemcp.handbook.model.agent.*;
import com.gentoro.onemcp.handbook.model.regression.RegressionSuite;
import com.gentoro.onemcp.utility.JacksonUtility;
import com.google.common.hash.Hashing;
import java.io.IOException;
import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.stream.Collectors;
import org.apache.commons.codec.binary.Base64;

public class HandbookImpl implements Handbook {
  private final OneMcp oneMcp;
  private final Path location;

  private Agent agent = null;
  private final Map<String, RegressionSuite> regressionSuites = new HashMap<>();
  private final Map<String, String> documentation = new HashMap<>();

  public HandbookImpl(OneMcp oneMcp, Path location) {
    this.oneMcp = oneMcp;
    this.location = location;
    this.initialize();
  }

  private void initialize() {
    this.agent = loadYaml(Agent.class, "Agent.yaml");
    this.loadRegressionSuites();
    this.loadServices(this.agent);
    this.loadDocumentation();
  }

  private Path relativePath(String relativeUri) {
    Path relativePath = location.resolve(relativeUri);
    if (Files.exists(relativePath)) {
      if (!Files.isRegularFile(relativePath)) {
        throw new ConfigException(relativeUri + " must be a regular file");
      }
      return relativePath;
    }
    return null;
  }

  private <T> T loadYaml(Class<T> clazz, String relativeUri) {
    Path yamlPath = relativePath(relativeUri);
    if (yamlPath != null) {
      try {
        return JacksonUtility.getYamlMapper().readValue(yamlPath.toFile(), clazz);
      } catch (Exception e) {
        throw new ConfigException("Failed to load " + relativeUri, e);
      }
    }
    return null;
  }

  private void loadServices(Agent agent) {

    if (this.agent == null || (this.agent.getApis() != null && this.agent.getApis().isEmpty())) {
      Path apisPath = location.resolve("./apis");
      if (Files.exists(apisPath) && Files.isDirectory(apisPath)) {
        try {
          Files.walk(apisPath)
              .forEach(
                  file -> {
                    if (Files.isRegularFile(file)
                        && file.getFileName().toString().toLowerCase().endsWith(".yaml")) {
                      Service service = new Service(this, file);
                      agent.addApi(service.getApiDef());
                    }
                  });
          Release release = new Release();
          release.setVersion("0.0.1");
          release.setDescription("Initial release auto-generated by OneMCP");
          release.setDate(
              DateTimeFormatter.ofPattern("yyyy-MM-dd").format(java.time.LocalDateTime.now()));

          Author author = new Author();
          author.setName("OneMCP");
          release.setAuthor(author);

          agent.getReleases().add(release);
        } catch (Exception e) {
          throw ExceptionUtil.rethrowIfUnchecked(
              e,
              (ex) ->
                  new IoException(
                      "Failed to process Regression suites definitions under the path: " + location,
                      ex));
        }
      }
    } else {
      if (agent.getApis() != null) {
        agent
            .getApis()
            .forEach(
                api -> {
                  api.bindHandbook(this);
                });
      }
    }
  }

  private void loadRegressionSuites() {
    try {
      Path regressionSuitesPath = location.resolve("regression-suites");
      if (Files.exists(regressionSuitesPath) && Files.isDirectory(regressionSuitesPath)) {
        Files.walk(regressionSuitesPath)
            .forEach(
                file -> {
                  if (Files.isRegularFile(file)
                      && file.getFileName().toString().toLowerCase().endsWith(".yaml")) {
                    RegressionSuite suite =
                        loadYaml(RegressionSuite.class, location.relativize(file).toString());
                    if (suite != null) {
                      regressionSuites.put(location.relativize(file).toString(), suite);
                    }
                  }
                });
      }
    } catch (Exception e) {
      throw ExceptionUtil.rethrowIfUnchecked(
          e,
          (ex) ->
              new IoException(
                  "Failed to process Regression suites definitions under the path: " + location,
                  ex));
    }
  }

  private void loadDocumentation() {
    try {
      Path docsPath = location.resolve("docs");
      if (Files.exists(docsPath) && Files.isDirectory(docsPath)) {
        Files.walk(docsPath)
            .forEach(
                file -> {
                  if (Files.isRegularFile(file)
                      && file.getFileName().toString().toLowerCase().endsWith(".md")) {
                    try {
                      documentation.put(
                          location.relativize(file).toString(), Files.readString(file));
                    } catch (IOException e) {
                      throw new IoException("Could not read documentation file: " + file, e);
                    }
                  }
                });
      }
    } catch (Exception e) {
      throw ExceptionUtil.rethrowIfUnchecked(
          e,
          (ex) ->
              new IoException(
                  "Failed to process Regression suites definitions under the path: " + location,
                  ex));
    }
  }

  @Override
  public Map<String, String> documentation() {
    return Collections.unmodifiableMap(documentation);
  }

  @Override
  public Optional<String> optionalDocumentation(String relativePath) {
    return documentation.containsKey(relativePath)
        ? Optional.of(documentation.get(relativePath))
        : Optional.empty();
  }

  @Override
  public String documentation(String relativePath) {
    return optionalDocumentation(relativePath)
        .orElseThrow(() -> new NotFoundException("Documentation not found: " + relativePath));
  }

  @Override
  public Path location() {
    return location;
  }

  @Override
  public Optional<Api> optionalApi(String slug) {
    return agent.getApis().stream().filter(api -> api.getSlug().equals(slug)).findFirst();
  }

  @Override
  public Api api(String slug) {
    return optionalApi(slug).orElseThrow(() -> new NotFoundException("API not found: " + slug));
  }

  @Override
  public Map<String, Api> apis() {
    return agent.getApis().stream()
        .map(api -> Map.entry(api.getSlug(), api))
        .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
  }

  @Override
  public Agent agent() {
    return agent;
  }

  @Override
  public Map<String, RegressionSuite> regressionSuites() {
    return Collections.unmodifiableMap(regressionSuites);
  }

  @Override
  public Optional<RegressionSuite> optionalRegressionSuite(String relativePath) {
    return regressionSuites.containsKey(relativePath)
        ? Optional.of(regressionSuite(relativePath))
        : Optional.empty();
  }

  @Override
  public RegressionSuite regressionSuite(String relativePath) {
    return optionalRegressionSuite(relativePath)
        .orElseThrow(() -> new NotFoundException("Regression suite not found: " + relativePath));
  }

  @Override
  public OneMcp oneMcp() {
    return oneMcp;
  }

  @Override
  public String name() {
    return Base64.encodeBase64String(
            Hashing.sha256()
                .hashBytes(location().toString().getBytes(StandardCharsets.UTF_8))
                .asBytes())
        .replaceAll("[^0-9a-zA-Z]", "");
  }
}
