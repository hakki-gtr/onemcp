#!/bin/bash
set -e

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
DIM='\033[0;2m'
NC='\033[0m' # No Color

# Script directory
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/../.." && pwd)"
SERVER_DIR="$PROJECT_ROOT/packages/server"
GO_CLI="$PROJECT_ROOT/packages/go-cli/onemcp"

# Config paths
CONFIG_FILE="$HOME/.onemcp/config.yaml"
LOG_DIR="$HOME/.onemcp/logs"

# Default values
MODE="fast"
DOCKER_MODE=false
SERVER_PID=""
FOLLOW_LOGS=false

# Cleanup function
cleanup() {
    if [ -n "$SERVER_PID" ]; then
        echo -e "${DIM}Stopping local server (PID: $SERVER_PID)...${NC}"
        kill "$SERVER_PID" 2>/dev/null || true
        wait "$SERVER_PID" 2>/dev/null || true
        echo -e "${DIM}âœ“ Server stopped${NC}"
    fi
}

trap cleanup EXIT INT TERM

# Parse arguments
COMMAND=""
while [[ $# -gt 0 ]]; do
    case $1 in
        logs)
            # Show logs command
            COMMAND="logs"
            shift
            ;;
        --docker)
            DOCKER_MODE=true
            shift
            ;;
        --clean)
            MODE="clean"
            shift
            ;;
        --follow|-f)
            FOLLOW_LOGS=true
            shift
            ;;
        *)
            if [ -z "$COMMAND" ]; then
                COMMAND="$1"
            fi
            shift
            ;;
    esac
done

# Default command is "chat"
if [ -z "$COMMAND" ]; then
    COMMAND="chat"
fi

# Handle logs command
if [ "$COMMAND" = "logs" ]; then
    LATEST_LOG="$LOG_DIR/dev-latest.log"
    if [ -f "$LATEST_LOG" ]; then
        if [ "$FOLLOW_LOGS" = true ]; then
            echo -e "${DIM}Following logs (Ctrl+C to stop)...${NC}"
            tail -f "$LATEST_LOG"
        else
            echo -e "${DIM}Showing last 50 lines of dev logs:${NC}"
            echo -e "${DIM}Log file: $LATEST_LOG${NC}"
            echo ""
            tail -n 50 "$LATEST_LOG"
        fi
    else
        echo -e "${YELLOW}No dev logs found${NC}"
        echo -e "${DIM}Logs will be created when you run: ./dev-cli/onemcp-dev chat${NC}"
    fi
    exit 0
fi

# Check if Go CLI exists
if [ ! -f "$GO_CLI" ]; then
    echo -e "${RED}Error: Go CLI not found at $GO_CLI${NC}"
    echo -e "${YELLOW}Please build the Go CLI first:${NC}"
    echo -e "  cd packages/go-cli && go build"
    exit 1
fi

# Check if config exists
if [ ! -f "$CONFIG_FILE" ]; then
    echo -e "${YELLOW}No config found. Please run setup first:${NC}"
    echo -e "  $GO_CLI"
    exit 1
fi

# Helper function to read YAML config
get_config() {
    local key="$1"
    local default="$2"
    
    # Simple grep-based YAML parsing (works for simple key: value pairs)
    local value=$(grep "^${key}:" "$CONFIG_FILE" 2>/dev/null | sed "s/^${key}: *//;s/\"//g;s/'//g" | tr -d '\r')
    
    if [ -z "$value" ]; then
        echo "$default"
    else
        echo "$value"
    fi
}

# Helper function to get nested API keys
get_api_key() {
    local provider="$1"
    # Look for "  openai: sk-..." pattern (4 spaces indent under apikeys)
    # Try both 'apikeys' (lowercase) and 'apiKeys' (camelCase) for compatibility
    local key=$(grep -A 10 "^apikeys:" "$CONFIG_FILE" 2>/dev/null | grep "^    ${provider}:" | sed "s/^    ${provider}: *//;s/\"//g;s/'//g" | tr -d '\r')
    if [ -z "$key" ]; then
        key=$(grep -A 10 "^apiKeys:" "$CONFIG_FILE" 2>/dev/null | grep "^  ${provider}:" | sed "s/^  ${provider}: *//;s/\"//g;s/'//g" | tr -d '\r')
    fi
    echo "$key"
}

# Check if command needs local server or can be passed through
# Only 'chat' needs the local server, other commands just use config
NEEDS_SERVER=false
if [ "$COMMAND" = "chat" ]; then
    NEEDS_SERVER=true
fi

# If command doesn't need server, just pass through to Go CLI
if [ "$NEEDS_SERVER" = false ]; then
    echo -e "${DIM}Running command: $COMMAND${NC}"
    exec "$GO_CLI" "$COMMAND" "$@"
fi

if [ "$DOCKER_MODE" = true ]; then
    echo -e "${BLUE}ðŸ³ Docker Build Mode${NC}"
    echo ""
    
    # Check for buildah or podman (required by build scripts)
    if ! command -v buildah &> /dev/null && ! command -v podman &> /dev/null; then
        echo -e "${YELLOW}âš ï¸  Docker mode requires buildah or podman (not standard Docker)${NC}"
        echo ""
        echo -e "${DIM}The project's Docker build scripts use buildah/podman for multi-arch builds.${NC}"
        echo ""
        echo -e "${YELLOW}Options:${NC}"
        echo -e "  1. ${GREEN}Use fast mode instead${NC} (recommended for development):"
        echo -e "     ${DIM}./packages/dev-cli/onemcp-dev chat${NC}"
        echo ""
        echo -e "  2. Install buildah or podman:"
        echo -e "     ${DIM}brew install buildah${NC}   # or"
        echo -e "     ${DIM}brew install podman${NC}"
        echo ""
        echo -e "  3. Build base + product images manually:"
        echo -e "     ${DIM}cd scripts/docker${NC}"
        echo -e "     ${DIM}./build-base.sh latest${NC}"
        echo -e "     ${DIM}./build-product.sh dev${NC}"
        echo -e "     ${DIM}# Then: ../../packages/go-cli/onemcp chat --image=admingentoro/gentoro:dev${NC}"
        exit 1
    fi
    
    echo -e "${DIM}Building custom Docker image from local code...${NC}"
    echo ""
    
    # Clean old dev images to prevent accumulation
    echo -e "${DIM}Cleaning old dev images...${NC}"
    # Remove from Docker/OrbStack
    docker rmi admingentoro/gentoro:dev admingentoro/gentoro:latest localhost/admingentoro/gentoro:dev 2>/dev/null || true
    # Remove from Podman
    podman rmi admingentoro/gentoro:dev admingentoro/gentoro:latest localhost/admingentoro/gentoro:dev localhost/admingentoro/gentoro:latest 2>/dev/null || true
    echo ""
    
    # Check if base image exists in either Podman or Docker
    if ! podman images | grep -q "admingentoro/gentoro.*base-latest" && \
       ! docker images | grep -q "admingentoro/gentoro.*base-latest"; then
        echo -e "${YELLOW}Base image not found. Building it first...${NC}"
        echo ""
    elif [ "$MODE" = "clean" ]; then
        echo -e "${YELLOW}Clean mode: Rebuilding base image...${NC}"
        echo ""
        # Remove existing base images for clean rebuild
        podman rmi localhost/admingentoro/gentoro:base-latest docker.io/admingentoro/gentoro:base-latest 2>/dev/null || true
        
        # Build base image using the project's script
        cd "$PROJECT_ROOT"
        if [ -f "scripts/docker/build-base.sh" ]; then
            bash scripts/docker/build-base.sh latest
        else
            echo -e "${RED}Error: Base image build script not found${NC}"
            echo -e "${YELLOW}Please build the base image first:${NC}"
            echo -e "  cd scripts/docker && ./build-base.sh latest"
            exit 1
        fi
        echo ""
    fi
    
    # Build product image using the project's script
    echo -e "${DIM}Building product Docker image...${NC}"
    cd "$PROJECT_ROOT"
    if [ -f "scripts/docker/build-product.sh" ]; then
        bash scripts/docker/build-product.sh dev
    else
        echo -e "${RED}Error: Product image build script not found${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}âœ“ Docker image built: admingentoro/gentoro:dev${NC}"
    
    # Remove redundant :latest tags to save space
    echo -e "${DIM}Cleaning up redundant tags...${NC}"
    podman rmi localhost/admingentoro/gentoro:latest 2>/dev/null || true
    echo ""
    
    # Transfer image from Podman to Docker (since Go CLI uses Docker/OrbStack)
    echo -e "${DIM}Transferring image to Docker/OrbStack...${NC}"
    TMP_TAR="/tmp/onemcp-dev-$$.tar"
    
    if podman save admingentoro/gentoro:dev -o "$TMP_TAR" 2>/dev/null; then
        if docker load -i "$TMP_TAR" 2>/dev/null; then
            # Tag it without localhost prefix so Docker can find it
            docker tag localhost/admingentoro/gentoro:dev admingentoro/gentoro:dev 2>/dev/null || true
            echo -e "${GREEN}âœ“ Image transferred to Docker${NC}"
        else
            echo -e "${YELLOW}âš ï¸  Could not load image into Docker${NC}"
            echo -e "${DIM}The image is available in Podman but not Docker${NC}"
        fi
        rm -f "$TMP_TAR"
    else
        echo -e "${YELLOW}âš ï¸  Could not save image from Podman${NC}"
    fi
    echo ""
    
    # Use Go CLI with custom image
    echo -e "${DIM}Starting with Go CLI...${NC}"
    exec "$GO_CLI" "$COMMAND" --image=admingentoro/gentoro:dev
    
else
    echo -e "${BLUE}âš¡ Fast Local Mode${NC}"
    echo ""
    
    # Clean old OrientDB data
    if [ -d "$SERVER_DIR/data/orient" ]; then
        echo -e "${DIM}Cleaning old database files...${NC}"
        rm -rf "$SERVER_DIR/data/orient"/*
    fi
    
    # Build server
    echo -e "${DIM}Building Java server...${NC}"
    cd "$SERVER_DIR"
    
    if [ "$MODE" = "clean" ]; then
        echo -e "${DIM}Running clean build...${NC}"
        mvn clean package -DskipTests -q
    else
        echo -e "${DIM}Running incremental build...${NC}"
        mvn package -DskipTests -q
    fi
    
    # Find the JAR
    JAR_FILE=$(find target -name "onemcp-*-jar-with-dependencies.jar" | head -n 1)
    
    if [ -z "$JAR_FILE" ]; then
        echo -e "${RED}Error: Could not find built JAR${NC}"
        echo -e "${YELLOW}Expected pattern: onemcp-*-jar-with-dependencies.jar${NC}"
        exit 1
    fi
    
    echo -e "${GREEN}âœ“ Build complete${NC}"
    echo -e "${DIM}JAR: $JAR_FILE${NC}"
    echo ""
    
    # Read config
    PORT=$(get_config "defaultPort" "8080")
    PROVIDER=$(get_config "provider" "gemini")
    CURRENT_HANDBOOK=$(get_config "currentHandbook" "")
    HANDBOOK_DIR=$(get_config "handbookDir" "$HOME/onemcp-handbooks")
    
    # Get API keys
    OPENAI_KEY=$(get_api_key "openai")
    GEMINI_KEY=$(get_api_key "gemini")
    ANTHROPIC_KEY=$(get_api_key "anthropic")
    
    # Determine handbook path
    if [ -n "$CURRENT_HANDBOOK" ] && [ "$CURRENT_HANDBOOK" != "acme-analytics" ]; then
        HANDBOOK_PATH="$HANDBOOK_DIR/$CURRENT_HANDBOOK"
    else
        HANDBOOK_PATH=""
    fi
    
    # Setup logging
    mkdir -p "$LOG_DIR"
    TIMESTAMP=$(date +%Y-%m-%d-%H-%M-%S)
    LOG_FILE="$LOG_DIR/dev-$TIMESTAMP.log"
    LATEST_LOG="$LOG_DIR/dev-latest.log"
    ln -sf "$LOG_FILE" "$LATEST_LOG"
    
    # Check for port conflicts
    if lsof -Pi ":$PORT" -sTCP:LISTEN -t > /dev/null 2>&1; then
        echo -e "${RED}Error: Port $PORT is already in use${NC}"
        echo -e "${YELLOW}Options:${NC}"
        echo -e "  1. Kill the process: ${DIM}lsof -ti:$PORT | xargs kill -9${NC}"
        echo -e "  2. Change port in config: ${DIM}$CONFIG_FILE${NC}"
        exit 1
    fi
    
    # Start server
    echo -e "${DIM}Starting local server on port $PORT...${NC}"
    echo -e "${DIM}Logs: $LOG_FILE${NC}"
    
    export SERVER_PORT="$PORT"
    export INFERENCE_DEFAULT_PROVIDER="$PROVIDER"
    export OPENAI_API_KEY="$OPENAI_KEY"
    export GEMINI_API_KEY="$GEMINI_KEY"
    export ANTHROPIC_API_KEY="$ANTHROPIC_KEY"
    export ONEMCP_LOG_DIR="$LOG_DIR"  # Reports will go to ~/.onemcp/logs/reports/
    
    if [ -n "$HANDBOOK_PATH" ]; then
        export HANDBOOK_DIR="$HANDBOOK_PATH"
        echo -e "${DIM}Handbook: $HANDBOOK_PATH${NC}"
    fi
    
    # Start Java server in background
    java -jar "$JAR_FILE" --mode server > "$LOG_FILE" 2>&1 &
    SERVER_PID=$!
    
    echo -e "${DIM}Server PID: $SERVER_PID${NC}"
    echo -e "${DIM}Waiting for server to be ready...${NC}"
    
    # Wait for health check
    MAX_WAIT=60
    ELAPSED=0
    while [ $ELAPSED -lt $MAX_WAIT ]; do
        if curl -s "http://localhost:$PORT/actuator/health" > /dev/null 2>&1; then
            echo -e "${GREEN}âœ“ Server is ready!${NC}"
            echo ""
            break
        fi
        sleep 1
        ELAPSED=$((ELAPSED + 1))
        
        # Check if process is still running
        if ! kill -0 "$SERVER_PID" 2>/dev/null; then
            echo -e "${RED}Error: Server process died${NC}"
            echo -e "${YELLOW}Last 20 lines of log:${NC}"
            tail -n 20 "$LOG_FILE"
            exit 1
        fi
    done
    
    if [ $ELAPSED -ge $MAX_WAIT ]; then
        echo -e "${RED}Error: Server failed to start within ${MAX_WAIT}s${NC}"
        echo -e "${YELLOW}Last 20 lines of log:${NC}"
        tail -n 20 "$LOG_FILE"
        exit 1
    fi
    
    # Use Go CLI in local mode
    echo -e "${DIM}Starting Go CLI...${NC}"
    if [ "$FOLLOW_LOGS" = true ]; then
        echo -e "${DIM}Tip: Logs are in: $LOG_FILE${NC}"
        echo -e "${DIM}Run 'tail -f $LOG_FILE' in another terminal to follow logs${NC}"
        echo ""
    fi
    "$GO_CLI" "$COMMAND" --local
fi
