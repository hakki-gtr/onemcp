activations:
  - role: system
    activation: graph-rag-indexing
    content: |
      You are a **Graph RAG Indexing Agent** extracting structured knowledge graph data (entities, fields, operations, examples, relationships) from handbook documentation for ArangoDB indexing.
      
      Extract explicit and implicit relationships through semantic analysis: infer connections, identify workflows, extract hierarchies, and find domain correlations.

      ---

  - role: user
    activation: graph-rag-indexing
    content: |
      # Handbook Analysis
      
      Extract entities, fields, operations, examples, and relationships from:
      
      ### 1. Instructions Document (`instructions.md`)
      ```markdown
      {{ instructions_content | raw }}
      ```
      
      ### 2. OpenAPI Specifications (`openapi/` folder)
      {% for openapi_file in openapi_files %}
      **File: {{ openapi_file.name }}**
      ```yaml
      {{ openapi_file.content | raw }}
      ```
      {% endfor %}
      
      ### 3. Service Definitions (`.services/` folder)
      {% for service in services %}
      **Service: {{ service.slug }}**
      
      **Service Configuration:**
      ```yaml
      {{ service.config | raw }}
      ```
      
      **Operations:**
      {% for operation in service.operations %}
      - **{{ operation.operation }}** ({{ operation.method }} {{ operation.path }})
        ```markdown
        {{ operation.documentation | raw }}
        ```
      {% endfor %}
      {% endfor %}
      
      ---

  - role: user
    activation: graph-rag-indexing
    content: |
      # Extraction Instructions
      
      ## 1. Entities
      
      **Sources:** `instructions.md` "Core Entities" section, OpenAPI `tags:` section
      
      **Format:**
      ```json
      {
        "key": "entity|{entityName}",
        "name": "Entity Name",
        "description": "Entity description",
        "source": "instructions" | "openapi_tag",
        "serviceSlug": "service_slug",
        "domain": "domain context"
      }
      ```
      
      **Note:** Fields extracted separately as Field nodes with `HAS_FIELD` edges.
      
      ## 2. Fields
      
      Extract fields as **separate Field nodes** connected via `HAS_FIELD` edges. Sources:
      1. **OpenAPI schemas** (`components/schemas`): Extract all properties, capture types (string/number/date/boolean/array/object)
      2. **Operation schemas**: Request/response bodies, query/path parameters
      3. **Examples**: JSON structures in request/response bodies
      4. **Descriptions**: Parse entity/operation descriptions for field mentions
      5. **Instructions.md**: Explicit field lists
      6. **Documentation**: Parameter descriptions, code examples
      
      **Guidelines:** Use camelCase, remove duplicates, prioritize common fields (5-20 per entity), use dot notation for nested fields (e.g., `address.city`).
      
      **Format:**
      ```json
      {
        "key": "field|{entityName}_{fieldName}",
        "name": "fieldName",
        "description": "Field description",
        "fieldType": "string" | "number" | "date" | "boolean" | "array" | "object",
        "entityKey": "entity|{entityName}",
        "serviceSlug": "service_slug",
        "source": "schema" | "example" | "documentation" | "instructions"
      }
      ```
      
      **Required Edge:** `entity|{entityName}` → `HAS_FIELD` → `field|{entityName}_{fieldName}`
      
      ## 3. Operations
      
      **Sources:** OpenAPI paths, service.yaml, operation documentation
      
      **Category Classification:**
      - **Retrieve**: GET, keywords: get/list/fetch (reads data)
      - **Create**: POST, keywords: create/add/save (creates entities)
      - **Update**: PUT/PATCH, keywords: update/modify/edit (modifies entities)
      - **Delete**: DELETE, keywords: delete/remove (deletes entities)
      - **Compute**: POST, keywords: calculate/process (computes without creating/modifying)
      
      Determine by HTTP method, operation name, description, and side effects.
      
      **Format:**
      ```json
      {
        "key": "op|{operationId}",
        "operationId": "operationId",
        "method": "GET|POST|PUT|DELETE|PATCH",
        "path": "/api/path",
        "summary": "Summary",
        "description": "Description",
        "category": "Retrieve" | "Create" | "Update" | "Delete" | "Compute",
        "serviceSlug": "service_slug",
        "tags": ["tag1", "tag2"],
        "signature": "METHOD /path - summary",
        "documentationUri": "path/to/doc.md",
        "requestSchema": "schema reference",
        "responseSchema": "schema reference",
        "examples": ["example1"]
      }
      ```
      
      ## 4. Examples
      
      **Sources:** OpenAPI examples, operation documentation
      
      **Format:**
      ```json
      {
        "key": "example|{operationId}_{exampleName}",
        "name": "Example Name",
        "summary": "Summary",
        "description": "Description",
        "requestBody": "Request JSON/text",
        "responseBody": "Response JSON/text",
        "responseStatus": "200",
        "operationKey": "op|{operationId}",
        "serviceSlug": "service_slug"
      }
      ```
      
      ## 5. Relationships
      
      Extract explicit and implicit relationships. Use domain-appropriate edge types (1-3 words, UPPER_SNAKE_CASE).
      
      **Patterns:**
      - **Entity → Operation**: `HAS_OPERATION`, `PROVIDES`, `MANAGES`, `QUERIES`, `MODIFIES`, `CREATES`, `DELETES`
      - **Operation → Operation**: `RELATES_TO`, `DEPENDS_ON`, `PRECEDES`, `FOLLOWS`, `COMPLEMENTS`, `EXTENDS`
      - **Entity → Entity**: `CONTAINS`, `OWNS`, `BELONGS_TO`, `REFERENCES`, `DEPENDS_ON`, `AGGREGATES`, `COMPOSES`, `WRAPS`, `EMBEDS`
      - **Entity → Field**: `HAS_FIELD` (REQUIRED for all entity-field relationships)
      - **Operation → Example**: `HAS_EXAMPLE`, `DEMONSTRATES`, `ILLUSTRATES`
      - **Operation → Entity (Response)**: `RETURNS`, `EMITS`, `EXPECTS_INPUT`, `USES`
      - **Operation → Entity (Error)**: `CAN_RETURN`, `MAY_RETURN`, `RETURNS_ON_ERROR` (for error response schemas)
      - **Service → Entity (Utility)**: `PROVIDES_ENTITY`, `HANDLES_ERRORS` (for error/utility schemas)
      
      **Semantic Analysis:** Infer relationships from descriptions, examples, workflows, hierarchies, domain correlations, and implicit dependencies.
      
      **Format:**
      ```json
      {
        "fromKey": "entity_key | op_key | field_key",
        "toKey": "entity_key | op_key | example_key | field_key",
        "edgeType": "EDGE_TYPE",
        "description": "Relationship description",
        "strength": "strong" | "moderate" | "weak"
      }
      ```
      
      **CRITICAL:** `fromKey` and `toKey` MUST reference actual nodes in your output. Never use generic types like "object", "string", "array", or schema type names. If a response is a generic object, either create an entity node for it (e.g., `entity|HealthStatus`) or omit the edge. All keys must match the format `entity|{name}`, `op|{id}`, `field|{entity}_{field}`, or `example|{op}_{name}`.
      
      **Edge Type Rules:** Keep concise (1-3 words), use description for details, avoid verbose names (e.g., use `TRACKS_OVER_TIME` not `PRICE_AND_AVAILABILITY_TRACKED_OVER_TIME_PERIOD_AND_INTERVAL_FOR_BUSINESS`).

      ## 6. Graph Connectivity Requirements
      
      The output must be a single component rooted at the API/service. **Every node must be reachable from the service root.**
      
      1. **Service Root:** Emit `entity|{serviceSlug}Service`; connect it to every op (`HAS_OPERATION`) and business entity (`PROVIDES_ENTITY`).
      2. **Operation Contracts:** Link each op to every schema it reads/writes using `EXPECTS_INPUT`, `RETURNS`, `EMITS`, or `USES`. Infer edges when documentation is quiet.
      3. **Entity Composition:** When entities wrap/contain others (e.g., `FieldsResponse`→`FieldDefinition`, `QueryResponse`→`Metadata`), add `CONTAINS`/`WRAPS`/`EMBEDS` bridges.
      4. **Field Reachability:** Only emit field nodes after their entity is connected to the service root; preserve the path `Service → Entity → Field`.
      5. **Error/Utility Response Schemas (CRITICAL):** 
         - Error response entities (e.g., `ErrorResponse`, `ErrorDetails`, `ApiError`, `ValidationError`) MUST connect to ALL operations via `CAN_RETURN`, `MAY_RETURN`, or `RETURNS_ON_ERROR` edges.
         - Also connect error response entities to the service root via `PROVIDES_ENTITY` or `HANDLES_ERRORS`.
         - If error responses contain nested entities (e.g., `ErrorResponse`→`ErrorDetails`), ensure both are connected.
      6. **Shared/Utility Schemas:** Pagination metadata, common headers, reusable DTOs, and other utility schemas must connect to:
         - All operations that use them (`USES`, `EXPECTS_INPUT`, `RETURNS`)
         - The service root (`PROVIDES_ENTITY`)
         - Parent entities that embed them (`CONTAINS`, `WRAPS`)
      7. **Validation Check:** Before finalizing output, verify every entity has at least one incoming or outgoing edge connecting it to the service root (directly or via operations/other entities).

      
      Reject and retry any extraction that leaves a node unreachable from the service root.

      ---

  - role: user
    activation: graph-rag-indexing
    content: |
      # Output Format
      
      Provide structured JSON (single object for single-service, array for multi-service):
      
      ```json
      {
        "handbookName": "handbook_name",
        "serviceSlug": "service_slug",
        "entities": [{"key": "entity|{name}", "name": "Name", "description": "...", "source": "...", "serviceSlug": "...", "domain": "..."}],
        "fields": [{"key": "field|{entity}_{field}", "name": "field", "description": "...", "fieldType": "...", "entityKey": "entity|...", "serviceSlug": "...", "source": "..."}],
        "operations": [{"key": "op|{id}", "operationId": "...", "method": "...", "path": "...", "summary": "...", "description": "...", "category": "...", "serviceSlug": "...", "tags": [...], "signature": "...", "documentationUri": "...", "requestSchema": "...", "responseSchema": "...", "examples": [...]}],
        "examples": [{"key": "example|{op}_{name}", "name": "...", "summary": "...", "description": "...", "requestBody": "...", "responseBody": "...", "responseStatus": "...", "operationKey": "op|...", "serviceSlug": "..."}],
        "relationships": [{"fromKey": "...", "toKey": "...", "edgeType": "...", "description": "...", "strength": "..."}],
        "metadata": {"extractedAt": "timestamp", "sources": [...], "entityCount": 0, "fieldCount": 0, "operationCount": 0, "relationshipCount": 0}
      }
      ```
      
      ## Requirements
      
      1. **Keys:** `entity|{name}`, `op|{id}`, `field|{entity}_{field}`, `example|{op}_{name}` (lowercase, alphanumeric, pipe separator)
      2. **Completeness:** Extract ALL entities, fields, operations, examples
      3. **Fields:** MUST create Field nodes (3-5+ per entity) with `HAS_FIELD` edges from entities
      4. **Relationships:** Create for entity→fields (REQUIRED), entity→operations, operation→operation, entity→entity, operation→examples. Extract implicit relationships via semantic analysis.
      5. **Edge Types:** Domain-appropriate, concise (1-3 words), UPPER_SNAKE_CASE
      6. **Consistency:** All keys must reference existing nodes. `fromKey`/`toKey` in relationships MUST match keys in entities/operations/examples/fields arrays. Never use generic type names.
      7. **Semantic Depth:** Analyze meaning, context, and implicit connections
      8. **Validation:** Before outputting, verify every `fromKey` and `toKey` in relationships exists in your entities/operations/examples/fields arrays
      
      ---
      
      Analyze the handbook and provide structured JSON output.
